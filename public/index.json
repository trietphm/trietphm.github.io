[{"content":"","date":"3 March 2019","permalink":"/tags/android/","section":"Tags","summary":"","title":"android"},{"content":"","date":"3 March 2019","permalink":"/tags/app/","section":"Tags","summary":"","title":"app"},{"content":"","date":"3 March 2019","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"3 March 2019","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"3 March 2019","permalink":"/","section":"triet.dev","summary":"","title":"triet.dev"},{"content":" Nhân dịp mới mua domain https://triet.dev + mới đổi sang dùng \u0026ldquo;quốc thoại\u0026rdquo; Xiaomi gần đây nên viết bài này. Câu hỏi mình thường gặp nhất từ bạn bè (IT) là \u0026ldquo;không sợ bị Xiaomi tracking/gửi dữ liệu về TQ này kia sao?\u0026rdquo;. Dĩ nhiên là có, mình hơi dị ứng một chút với việc bị tracking và một số thể loại chạy app chạy background để thực hiện một vài thứ được cho là để \u0026ldquo;gia tăng trải nghiệm\u0026rdquo;. Thế nên các app mình dùng hơi \u0026ldquo;khác người\u0026rdquo; một chút và đôi khi hơi phiền phức, nhưng bù lại mình thấy yên tâm hơn phần nào về privacy. Ngoài ra, viết bài này cũng vì một số bạn hỏi xem \u0026ldquo;có app gì hay ho không, giới thiệu với\u0026rdquo;. Mình liệt kê một vài app có lẽ ít người biết nhưng rất hữu dụng. TL;DR  F-Droid Blokada Greenify SlimSocial 1Password Nova Launcher GadgetBridge Authy Firefox + Addon Google Podcasts Genious Scan Skytube Manga Reader     1. F-droid #  Thứ đầu tiên mình cài là F-droid, là một dạng App Store khác như Google Play Store, nhưng đây là một community-maintained software repository của Android. Nói cách khác đây là một App Store cho mã nguồn mở và nhiều app khác bị cấm trên Google Play, nguyên nhân cấm thì có nhiều nhưng đa phần ở đây không phải là vì virus/mã độc mà là do ảnh hưởng đến việc kinh doanh của công ty khác (sẽ đề cập đến các app phía sau) Nhiều ứng dụng phía sau cũng được tải từ F-Droid\nCác bạn có thể vào đây để download file APK về cài đặt https://f-droid.org/en/\nHầu hết các thứ mình cần đều sẽ search ở đây trước, nếu không có mới bắt đầu tìm ở Google Play    2. Blokada #    Nếu bạn đã dùng AdBlock, uBlock Origin,\u0026hellip; trên web browser sẽ không thể bỏ qua app này. App sẽ giúp bạn chặn các thể loại quảng cáo từ A-Z: từ quảng cáo trên web (Chrome, Firefox,\u0026hellip;), đến các quảng cáo in-app (tức các quảng cáo chạy trong các app khác), đến luôn các thể loại tracking, thu thập dữ liệu,\u0026hellip; từ chính Google, Xiaomi,\u0026hellip; tóm lại là toàn bộ thứ gì đi qua Network Connection trên điện thoại của bạn đều bị kiểm soát.\n  Ngoài ra Blokada còn cho phép set DNS và custom filter (tự tạo filter list), mình dùng custom filter để chặn Xiaomi tracking.\n  Hiển nhiên bạn sẽ không tìm thấy Blokada trên Google Play vì chặn quảng cáo = chặn nồi cơm của Google. Tải file APK ở trang chủ https://blokada.org/\n  hoặc vào F-droid và search Blokada để cài đặt https://f-droid.org/en/packages/org.blokada.alarm/    Cách Blokada hoạt động: nói ngắn gọn là Blockada sẽ tạo một VPN và mọi thứ đi qua VPN sẽ bị filter (quảng cáo) dựa trên filter list. Và app được optimize khá tốt, không hề tốn pin dù chạy 24/24. \u0026ldquo;Thế lỡ bị chính thằng Blokada nó track thì sao?\u0026rdquo; Blokada không track và có open source trên Github https://github.com/blokadaorg/blokada, bạn có thể vào check và ném đá nếu phát hiện ra.  Bất tiện:\n Nếu bạn chơi game và có mục dạng \u0026ldquo;Xem video quảng cáo để nhận quà\u0026rdquo; thì chắc chắn bạn sẽ không load được video nào (chặn hết rồi, obviously), nếu cần có thể tắt Blokada và mở lại game. Thỉnh thoảng một số app dùng các service tracking hoặc send SMS (verify tài khoản lúc đăng ký) sẽ không gửi request đi được và báo lỗi, tắt tạm Blokada lên send SMS rồi mở lại là xong.  Bonus: Filter list chặn hết các request đến Xiaomi\nhttps://gist.githubusercontent.com/trietphm/6b73a101c64c50c70ac8808bbc75730b/raw/be8d3121f3cb251b63e964d6c3ede8eb10609529/blokada-xiaomi-blocklist  3. Greenify #  Chặn các ứng dụng chạy nền (sync dữ liệu, push notification, tracking,\u0026hellip;) bằng cách hibernate (ngủ đông) app đó, không còn bị tốn Pin (rất nhiều) vào mấy thứ này, rất nhiều app dù bạn có tắt, force stop các kiểu nó vẫn chạy và ăn pin như thường. Các app sau khi bị hibernated sẽ chỉ \u0026ldquo;thức dậy\u0026rdquo; khi bạn chủ động mở nó lên. Có thể tải Greenify trên Google Play   https://play.google.com/store/apps/details?id=com.oasisfeng.greenify\u0026hl=en\nCó bản Pro (donate version - tốn tiền) có nhiều chức năng hơn và nếu máy bạn đã root thì càng mạnh mẽ hơn.\nQuick guide:\n Mở app lên, chọn (+) và chọn các app cần hibernate Mình thường set \u0026ldquo;Sleep and Hibernate\u0026rdquo; của Greenify làm Assist \u0026amp; voice input trong Default apps, để chỉ cần ấn giữ nút Home (trên màn hình) để tắt màn hình (lock máy) và hibernate cùng lúc.        4. SlimSocial #  Ứng dụng thay thế cho Facebook/Facebook Lite. Vì:\n Chặn quảng cáo Gọn nhẹ (~100KB) Open Source No tracking No background stuff Customizable (Dark mode, font size,\u0026hellip;)  Bản chất app này cũng chỉ wrap cái site touch.facebook.com lại và thêm một vài tùy biến nhỏ\nBất tiện: Không \u0026ldquo;xịn\u0026rdquo; và nhiều chức năng như app Facebook, hiển nhiên, nhưng đối với mình là quá đủ, chủ yếu để xem/like/comment là đủ, những thứ khác không cần thiết.\nCó thể tải SlimSocial trên Google Play hoặc F-Droid.\n Open source: https://github.com/rignaneseleo/SlimSocial-for-Facebook Google Play: https://play.google.com/store/apps/details?id=it.rignanese.leo.slimfacebook\u0026hl=en F-Droid: https://f-droid.org/en/packages/it.rignanese.leo.slimfacebook/      5. 1Password (Có phí) #  Gần như là must-have app vì hầu như toàn bộ password của mình là random generated và được lưu trong 1Password. Mỗi lần cần đăng nhập mình sẽ dùng 1Password để auto-fill. Ngoài ra, còn một vấn đề về security nữa là nếu bạn dùng một app keyboard bên thứ 3 (VD Laban key, GoTiengViet, Google Keyboard,\u0026hellip;) thì các app này có thể đọc và vô tình lưu password của bạn.\nVậy copy Password từ 1Password ra rồi paste vào là ổn? Thật sự thì chưa, vì bất cứ app nào cũng được quyền đọc Clipboard và biết được password của bạn. Tốt nhất nên dùng chức năng auto-fill của 1Password hoặc chuyển sang 1Password Keyboard mỗi lần nhập password. Bạn có thể xem thêm về security hole này ở đây: https://github.com/grepx/android-clipboard-security\n   Google Play: https://play.google.com/store/apps/details?id=com.agilebits.onepassword\u0026hl=en\n 6. Nova Launcher #  Thử rất nhiều Launcher nhưng đây là cái nhanh, ổn định, customizable nhất mình từng dùng. Ngoài ra các chức năng của bản Pro cũng đáng để bỏ tiền ra mua. Tải trên Google Play nha. https://play.google.com/store/apps/details?id=com.teslacoilsw.launcher\u0026hl=en\n 7. Gadgetbridge #  Mình có một cái vòng đeo tay Miband nhưng lại không muốn đưa dữ liệu cho Xiaomi, nhưng muốn xem dữ liệu activity/sleeping tracking thì phải sync với app Xiaomi Fit :( Và Gadgetbridge là giải pháp, một open-source Android app để thay thế cho app Xiaomi Fit. Ngoài ra, Gadgetbridge còn hổ trợ một số thiết bị đeo tay khác như Amazfit, Pebble,\u0026hellip;\nMặc dù UI/UX hơi bị chuối nhưng đối với mình cũng chấp nhận được.\n   F-Droid: https://f-droid.org/en/packages/nodomain.freeyourgadget.gadgetbridge/\n 8. Authy #  Giống như Google Authenticator nhưng có thể backup được, lỡ mất điện thoại còn có thể recovery lại. https://play.google.com/store/apps/details?id=com.authy.authy\u0026hl=en\n    9. Firefox #  Mình rất công nhận Chrome load nhanh hơn Firefox rất nhiều, nhưng vẫn dùng để ủng hộ Firefox. Ngoài ra còn vì Firefox Android có thể cài Add-on được.\n Tap Translate (để quick translate, chỉ cần select từ muốn tra sẽ có cái button hiện ra để dịch từ đó) User-Agent Switcher: để chuyển web-agent sang thành\u0026hellip; Chrome. Nhiều website của Google (Google search, Gmail,\u0026hellip;) load trên Firefox cực kỳ xấu (Google cố tình làm vậy), cả Facebook cũng giảm độ phân giải ảnh xuống, nên phải chỉnh agent thành chrome để giả mạo.   10. Google Podcasts #  Nếu bạn thường nghe Podcasts thì đây là một app không thể bỏ qua. Hàng chính chủ Google, đơn giản, gọn nhẹ, dễ dùng.\nGoogle Play: https://play.google.com/store/apps/details?id=com.google.android.apps.podcasts\u0026hl=en\n 11. Genious Scan #  Từ lúc CamScanner tính phí mình chuyển qua cái này để scan/chụp tài liệu bằng camera điện thoại, nhanh gọn lẹ. https://play.google.com/store/apps/details?id=com.thegrizzlylabs.geniusscan.free\u0026hl=en\n 12. SkyTube #  Dùng để xem và\u0026hellip; nghe YouTube. Vấn đề lớn nhất của app YouTube là bạn không thể tắt màn hình để nghe nhạc được (nhạc tắt theo luôn), trừ phi bạn có đăng ký YouTube Premium (đáng tiếc là cũng không available ở Việt Nam) Bạn có thể xem video trên SkyTube và tắt màn hình thoải mái. Do đạp nồi cơm của YouTube nên bạn chỉ có thể tải SkyTube trên F-Droid\nhttps://f-droid.org/en/packages/free.rm.skytube.oss/    13. Manga Reader #  The best in town! Là app đọc truyện tranh với rất nhiều nguồn khác nhau, từ tây đến ta đến tàu, ngoại trừ UI hơi chuối một chút thì những thứ còn lại cực kỳ ổn: https://play.google.com/store/apps/details?id=com.comikin.reader2\u0026hl=en\n","date":"3 March 2019","permalink":"/posts/android-app/","section":"Posts","summary":"Các ứng dụng mình hay cài đặt và sử dụng trên điện thoại Android","title":"Ứng dụng trên điện thoại Android [2019]"},{"content":"","date":"16 March 2018","permalink":"/tags/newsfeed/","section":"Tags","summary":"","title":"newsfeed"},{"content":"","date":"16 March 2018","permalink":"/tags/random/","section":"Tags","summary":"","title":"random"},{"content":" Các thuật toán sắp xếp newsfeed #   Một trong những tính năng thường gặp của những trang tin tức/mạng xã hội là newsfeed. Thông thường các trang này được thiết kế để hiển thị tin tức mới nhất (sort theo timestamp) hoặc những tin được ưa chuộng, đáng giá cao (sort theo hệ thống ranking được đánh giá dựa score/view/ như hackernews, reddit) hoặc đơn giản là theo ý thích của admin, mình thích thì mình đưa lên top thôi (kipalog). Tuy nhiên, hầu hết các dạng này đều phải sort dựa trên một giá trị nhất định và quan trọng nhất cần có một lượng bài viết liên tục đủ để tránh làm cho newsfeed không bị nhàm chán, nhìn chỉ có vài bài đăng đi đăng lại. Ngoài ra, không như các trang tin tức hằng ngày, chỉ cần qua một đêm là đã thành tin outdated, một số trang web chia sẽ tin tức, kiến thức lại không như vậy (ví dụ chia sẽ kiến thức thiên văn, văn học, lịch sử, kỹ năng,\u0026hellip; Hoặc chia sẽ các địa điểm, thông tin du lịch, mẹo vặt,\u0026hellip;), đồng thời lượng bài viết cũng không nhiều bằng. Và các thuật toán newsfeed ở bên trên chỉ có thể giúp người dùng tiếp cận được một lượng thông tin rất nhỏ. Và đôi khi do lượng bài cập nhật không liên tục (vd khoảng 1-2 ngày mới có 1 bài), khi user vào cứ thấy có vài bài vừa được đăng gần đây và kết luận site cùi quá, chả có gì hay, mặc dù còn một lượng bài viết rất lớn đã được đăng trước nhưng user không được tiếp cận. Để giải quyết tình trạng trên, bài viết dưới sẽ mô tả về việc random dữ liệu, đồng thời thiết kế newsfeed có vẻ có hơi hướm newsfeed base user (nội dung xây dựng dựa trên hành vi người dùng). Việc random có thể sẽ mang lại ưu và nhược điểm như sau: Ưu: tạo cảm giác dữ liệu phong phú, site active liên tục, mỗi lần user refresh/truy cập sẽ có được thông tin khác nhau, và mỗi lần load đều là trải nghiệm dữ liệu mới. Nhược: đôi khi user thấy gì đó hay ho, quay lại xem thì lại không tìm thấy cái cũ, random mà. Nhưng đôi khi đây cũng có thể coi là feature tùy theo business của product.   Random newsfeed #   Yêu cầu #  Để dễ hình như ta sẽ thiết kế một API newsfeeds trả về danh sách địa điểm ăn uống một cách ngẫu nhiên. Giả sử mình đang có trong tay tập dữ liệu của 10000 địa điểm với nội dung khác nhau và đang nằm trong DB SQL (Mysql/Postgresql). Newsfeed sẽ giống như timeline của Facebook, tức là cứ scroll xuống thì client sẽ request lên để lấy nội dung mới về. Và cần phải đảm bảo:\n  Mỗi lần reload newsfeed phải có nội dung random khác nhau giữa các lần reload.\n  Dữ liệu trả về ở mỗi lần load more (scroll xuống) phải đảm bảo không trùng với dữ liệu đã trả về trước đó.\n  Giả sử dữ liệu của mình có dạng đơn giản như sau:\n  eateries +-----+------+---------+------------+ | id | name | address | created_at | +-----+------+---------+------------+ | int | text | text | timestamp | +-----+------+---------+------------+  Và format API trả về sẽ có dạng như thế này:  { \u0026quot;data\u0026quot;: [ {\u0026lt;eatery_1\u0026gt;}, {\u0026lt;eatery_2\u0026gt;}, {\u0026lt;eatery_3\u0026gt;}, ... ], \u0026quot;pagination\u0026quot;: { \u0026quot;nextUrl\u0026quot;:\u0026quot;/newsfeeds?param1=x\u0026amp;param2=y\u0026amp;param3=z\u0026quot; } } Với format trên, client mỗi lần cần lấy thêm dữ liệu (load more) chỉ cần lấy nextUrl ra và request thẳng lên server mà không cần thêm thao tác gì khác, mọi thứ đều được quyết định ở server.\n Xây dựng #   Simple approach: Lọc phần tử trùng mỗi lần load #   Cách tiếp cận đơn giản nhất: mỗi lần load sẽ query random, đồng thời loại bỏ các địa điểm đã load trước đó, câu query sẽ có dạng như sau:  \tSELECT * FROM eateries WHERE id NOT IN (?) ORDER BY RANDOM()  Dữ liệu trong param ? nhận vào là danh sách id của những địa điểm đã load trước đó. Câu hỏi đặt ra là làm sao biết user hiện tại đã load những địa điểm nào rồi để bỏ qua? Cách đơn giản nhất là lưu thẳng danh sách địa điểm vào trong nextUrl và khi client request lên thì lọc ra. Ví dụ: Lần load đầu tiên đã lấy ra 3 điểm có id là [1, 2, 3]. Trong response trả về cho user sẽ là   \u0026quot;pagination\u0026quot;: { \u0026quot;nextUrl\u0026quot;:\u0026quot;/newsfeeds?ignoreEatery=1,2,3\u0026quot; }  Lần tới khi client request với nextUrl trên, ta sẽ có danh sách id cần loại ra, câu SQL của lần load kế tiếp sẽ là:   SELECT * FROM eateries WHERE id NOT IN (1,2,3) ORDER BY RANDOM() LIMIT 10   Vấn đề:\n  URL có giới hạn về số lượng ký tự, đâu đó tầm 2000 characters tùy theo browsers, nên chắc chắn không thể lưu được 10000 địa điểm.\n  Giả sử bằng cách nào đó có thể truy xuất được danh sách id cần loại ra ở trên, ví dụ ta sẽ cache tạm ở đâu đó trong memcache/redis, lúc nào cần thì đọc từ cache ra, sau đó query đến SQL database, khi response data về thì bổ sung thêm id mới vào cache. Có vẻ ổn nhưng thực tế sẽ phát sinh các vấn đề như sau:\n Server round trip: IDs phải luân chuyển từ cache -\u0026gt; application -\u0026gt; SQL Database -\u0026gt; Update to cache Query sử dụng điều kiện NOT IN sẽ không đảm bảo để sử dụng index (ví như ở trên id là primary key = đã indexed) nhưng db vẫn sẽ sequences scan, nguyên nhân vì planners thường sẽ dựa vào khá nhiều thông tin để quyết định xem có nên dùng index không, index nào, optimize thế nào để có performance tốt nhất và có thể sẽ đưa ra quyết định không chính xác, xem thêm Indexes and NOT Equal. Dưới đây là thông tin sau khi explain ra với data sample khoảng 80k records (Postgresql), thông tin chi tiết có thể xem ở đây https://explain.depesz.com/s/W7yl  \tEXPLAIN analyze SELECT * FROM orders WHERE id NOT IN (\u0026lt;List Ids here about 1000 items\u0026gt;) ORDER BY random() LIMIT 10 Limit (cost=109157.01..109157.04 rows=10 width=896) (actual time=804.610..804.614 rows=10 loops=1)   -\u0026gt; Sort (cost=109157.01..109348.06 rows=76419 width=896) (actual time=804.608..804.611 rows=10 loops=1) Sort Key: (random()) Sort Method: top-N heapsort Memory: 29kB -\u0026gt; Seq Scan on eateries (cost=0.00..107505.63 rows=76419 width=896) (actual time=0.024..743.249 rows=77288 loops=1) Filter: (id \u0026lt;\u0026gt; ALL ('{\u0026lt;List ids dài quáaaaaaaaaaaaaaaaaaaaaaaa}'::integer[])) Rows Removed by Filter: 783 Planning time: 1.187 ms Execution time: 804.675 ms\n - Per node type stats    node type count sum of times % of query     Limit 1 0.003 ms 0.0 %   Seq Scan 1 743.249 ms 92.4 %   Sort 1 61.362 ms 7.6 %     - Nhìn vào query plan ở trên ta thấy `NOT IN` đã được chuyển thành `id \u0026lt;\u0026gt; ALL('{}'::integer[])`, và quan trọng nhất là index trên primary key `id` đã không được dùng mà planner đã dùng sequence scan aka full scan table, chiếm 743ms, quá chậm. - Ngoài ra còn một vấn đề khác là hàm `RANDOM()` cũng làm ảnh hưởng đến tốc độ, 61.3ms, và thực tế con số này rất vô chừng có thể tăng hoặc giảm tùy theo database stats, nhưng có thể chắc chắn sẽ chậm với lượng data lớn. - Vậy có cách nào khác để tăng tốc cho hàm `RANDOM()` không? Có thể sử dụng một vài cách khác để pick ra được random data nhưng theo đánh giá cá nhân của mình sẽ đều có trade off, tức tốc độ query sẽ tỉ lệ nghịch với mức độ `random`, và thật sự mà nói cũng không thể cải thiện được nhiều. Xem thêm [Best way to select random rows PostgreSQL ](https://stackoverflow.com/questions/8674718/best-way-to-select-random-rows-postgresql), [Performance of ORDER BY RANDOM to select random rows?](https://www.postgresql.org/message-id/flat/CAL_0b1u0UavZbUQo__a2jr0Vq31n2YK0wbUkjxx6H%3DNUT1u0zA%40mail.gmail.com#CAL_0b1u0UavZbUQo__a2jr0Vq31n2YK0wbUkjxx6H=NUT1u0zA@mail.gmail.com) và [Quality of PostgreSQL's random() function? ](https://stackoverflow.com/questions/9816114/quality-of-postgresqls-random-function). Mình sử dụng postgresql là chính nên chỉ research về postgresql, nhưng cơ bản random là vấn đề của computer science nói chung nên mình nghĩ ở database khác cũng sẽ khó có cách tiếp cận tốt hơn, xem thêm về cách Cloudflare random bằng cách dùng đèn lava [LavaRand in Production: The Nitty-Gritty Technical Details](https://blog.cloudflare.com/lavarand-in-production-the-nitty-gritty-technical-details/) ","date":"16 March 2018","permalink":"/posts/random-newsfeeds/","section":"Posts","summary":"Các thuật toán sắp xếp newsfeed #   Một trong những tính năng thường gặp của những trang tin tức/mạng xã hội là newsfeed.","title":"Random newsfeed"},{"content":"","date":"16 March 2018","permalink":"/tags/redis/","section":"Tags","summary":"","title":"redis"},{"content":"","date":"12 December 2017","permalink":"/tags/go/","section":"Tags","summary":"","title":"go"},{"content":"","date":"12 December 2017","permalink":"/tags/golang/","section":"Tags","summary":"","title":"golang"},{"content":"","date":"12 December 2017","permalink":"/tags/log/","section":"Tags","summary":"","title":"log"},{"content":"    Vì sao cần phải log và cần phải log một cách chỉnh chu? #   Log là gì? #   Hiểu một cách đơn giản thì log là những thứ dùng để lưu vết, những thông tin được thông báo, lưu lại trong quá trình hoạt động của một ứng dụng. Thế ghi log như thế nào? Có thể output ra màn hình, lưu vào file, stdout đâu đó để có thể xem lại được. Ghi log để làm gì? Dĩ nhiên là để có thể xem lại các thông tin hoạt động của ứng dụng trong quá khứ nhằm nhiều mục đích như debug, check health, xem info, xem lỗi, warning,\u0026hellip; Nhưng ghi log là ghi gì? Cách đơn giản nhất là ghi lại toàn bộ thông tin nào bạn nghĩ là cần thiết để phục vụ cho các mục đích bên trên.   Vì sao cần viết log có tâm? #   Nếu bạn đã từng làm việc với những files log thể nào bạn cũng sẽ phải ăn ít nhất một trong những đống hành này: File log đó to quááááááááá (file to quá nên có tiếng vọng echo), làm sao để xem giờ T_T. Một mớ thông tin hỗn độn như spaghetti, đủ mọi thông tin từ Trái Đất tới sao Hỏa. Và bạn cũng chẳng thể nào biết được mớ thông tin trên đến từ đâu, từ ngữ cảnh nào, user nào,\u0026hellip; Và bạn muốn search cũng không search được, toàn raw text và chẳng theo cấu trúc nào. Đứa ngớ ngẩn nào đó log ra những đoạn trong có vẻ nguy hiểm: It works! Let\u0026rsquo;s have some beer nhưng hoàn toàn vô dụng. Đứa ít ngớ ngẩn hơn đã log ra cái lỗi nhưng chả thể nào biết được lỗi đó đến từ không gian thứ nguyên nào hay làm sao để reproduce, it said Null pointer exception, you die wahaha. Nếu các file đến từ nhiều server, services, application thì, well, let\u0026rsquo;s have some beer. Bạn có một file log nặng 50GB được lưu trong 1 tháng và ai đó nhờ bạn check giùm log của một ngày giữa tháng, well, wanna go grab some beer? \u0026hellip;      Log như thế nào? #   Log gì #   Việc đầu tiên trước khi output dòng log ra hãy tưởng tượng sau đó có thể sử dụng được không, hay chỉ là thông tin vô nghĩa. Đừng tự đánh lừa mình rằng \u0026ldquo;Trust me, tôi biết tôi đang ghi gì ra mà, một vài ký tự viết tắt thôi, ez\u0026rdquo;, dám cá là bạn sẽ quên ngay 5' sau đó. Hãy log nhiều thông tin nhất có thể, toàn bộ ngữ cảnh trong trường hợp đó. VD bạn cần log lại một request HTTP có response 500 Internal server error, thì thông tin ở đây ít nhất phải có: Thời gian HTTP request info: header, request, body,\u0026hellip; HTTP response info Các thông tin trên tương đối đủ để bạn có thể reproduce lại, tuy nhiên tốt hơn nên có đầy đủ stack trace về error đó như lỗi ở đoạn nào, dòng nào, lỗi gì, input như thế nào,\u0026hellip;   Phân loại log #   Log có thể xem là một dạng raw database nên cũng nên được phân loại tùy theo mục đích sử dụng, nhưng ít nhất nên được chia theo level: INFO: các thông tin mà bạn muốn collect thêm trong quá trình hoạt động của application. VD: log http request (link, status, duration,\u0026hellip;) để biết traffic thế nào DEBUG: các thông tin dùng để debug, hiển nhiên, có thể bật/tắt log này dựa vào mode của application. Bạn sẽ nghĩ cái nào debug log viết xong thì xóa chứ để làm gì nhỉ? Đúng là vậy, nhưng vẫn sẽ có một vài trường hợp cần thiết như quá trình đặt log debug tốn quá nhiều thời gian nếu làm rồi xóa đi rồi lại làm lại, hoặc một vài trường hợp hy hữu cần debug trên production (lol, vẫn có nhé), nhưng dĩ nhiên là không phải sửa code thẳng trên server mà chỉ bật/tắt debug mode thôi. WARNING: hơi khó phân biệt với error. Ở đây cá nhân mình thường log những thứ nguy hiểm, lỗi ít hoặc không gây nguy hiểm đến ứng dụng nhưng cần được fix sớm trong tương lai. VD bạn đang load sản phẩm ra từ trong Database nhưng lúc đó phát hiện user tạo sản phẩm đó không còn tồn tại trong Database, thay vì báo lỗi, bạn bùa phép trả về một user default nào đó và log warning lại, một dạng auto heal. ERROR: quá rõ ràng, error và toàn bộ thông tin liên quan nhiều nhất có thể để có thể reproduce lại được mà ít tốn thời gian nhất.   Format log #   Một điều quan trọng là log đó phải sử dụng được và dễ sử dụng: readable. Log nên được format theo định dạng của các standard library logger để có thể consume được. Có nhiều ứng dụng phục vụ cho việc collect data và analyze để có thể thống kê, search,\u0026hellip; từ log đó như Logstash, Fluentd, Graylog,\u0026hellip; Và file log nên follow theo format input của các ứng dụng này.      Log rotate #   Log rotate là việc cắt nhỏ log ra và lưu trữ trên nhiều file thay vì một file, có thể sẽ lưu log riêng theo từng ngày, tuần hoặc tháng. Bạn sẽ có nhiều file dạng như: mylog-20171201.log, mylog-20171202.log, mylog-20171202.log,\u0026hellip; Hoặc có thể file log sẽ cắt theo chiến lược khác như dung lượng file (vd tối đa 1GB), hoặc tùy theo mục đích cụ thể riêng của ứng dụng. Có thể thực hiện bằng nhiều cách như dùng logrotate trong linux hoặc một số logger library cũng support việc này.   Sử dụng Logrus trong Go #      Trong Golang built-in package đã có hổ trợ việc log https://golang.org/pkg/log/ nhưng khá đơn giản và không đáp ứng đủ những nhu cầu như trên. Logrus (https://github.com/sirupsen/logrus) là một structered logger cho Golang support hầu hết những thứ trên và output ra màu mè khá đẹp     Sử dụng khá dễ dàng, một ví dụ nhỏ:\npackage main import ( log \u0026quot;github.com/sirupsen/logrus\u0026quot; ) func main() { log.WithFields(log.Fields{ \u0026quot;animal\u0026quot;: \u0026quot;walrus\u0026quot;, }).Info(\u0026quot;A walrus appears\u0026quot;) }  Formater #  Logrus support format với 2 định dạng là:\n logrus.TextFormatter: Log ra dạng plain text, nếu stdout là tty sẽ có bổ sung thêm color. logrus.JSONFormatter: Log ra theo dạng json  \tlog.SetFormatter(\u0026amp;log.TextFormatter{}) log.SetFormatter(\u0026amp;log.JSONFormatter{})  Structed log #  Để đảm bảo log luôn được formated và parseable nên logrus bắt buộc log thông qua function WithFields\npackage main import ( \u0026quot;os\u0026quot; \u0026quot;github.com/sirupsen/logrus\u0026quot; ) func main() { logrus.SetFormatter(\u0026amp;logrus.TextFormatter{}) //log.SetFormatter(\u0026amp;log.JSONFormatter{}) var log = logrus.New() log.Out = os.Stdout // Log to file // file, err := os.OpenFile(\u0026quot;logrus.log\u0026quot;, os.O_CREATE|os.O_WRONLY, 0666) // if err == nil { // log.Out = file // } else { // log.Info(\u0026quot;Failed to log to file, using default stderr\u0026quot;) // } log.WithFields(logrus.Fields{ \u0026quot;event\u0026quot;: \u0026quot;event\u0026quot;, \u0026quot;topic\u0026quot;: \u0026quot;topic\u0026quot;, \u0026quot;key\u0026quot;: \u0026quot;key\u0026quot;, }).Fatal(\u0026quot;Failed to send event\u0026quot;) } Bằng cách này, dù muốn hay không log khi được lưu lại đều có cùng định dạng, ví dụ với đoạn code trên sẽ cho output là:\n Text format (tty):  FATA[0000] Failed to send event event=event key=key topic=topic  Text format (file):  time=\u0026quot;2017-12-12T20:08:20+07:00\u0026quot; level=fatal msg=\u0026quot;Failed to send event\u0026quot; event=event key=key topic=topic  Json format:  {\u0026quot;event\u0026quot;:\u0026quot;event\u0026quot;,\u0026quot;key\u0026quot;:\u0026quot;key\u0026quot;,\u0026quot;level\u0026quot;:\u0026quot;fatal\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;Failed to send event\u0026quot;,\u0026quot;time\u0026quot;:\u0026quot;2017-12-12T20:03:29+07:00\u0026quot;,\u0026quot;topic\u0026quot;:\u0026quot;topic\u0026quot;} Mặc định logrus sẽ bổ sung các field time, level, msg vào trong output log, khá tiện lợi.\n Level logging #  Logrus support 6 loại level: Debug, Info, Warn, Error, Fatal, Panic. Cách sử dụng như bên dưới:\nlog.Debug(\u0026quot;Useful debugging information.\u0026quot;) log.Info(\u0026quot;Something noteworthy happened!\u0026quot;) log.Warn(\u0026quot;You should probably take a look at this.\u0026quot;) log.Error(\u0026quot;Something failed but I'm not quitting.\u0026quot;) // Calls os.Exit(1) after logging log.Fatal(\u0026quot;Bye.\u0026quot;) // Calls panic() after logging log.Panic(\u0026quot;I'm bailing.\u0026quot;)  Log rotation #  Đáng tiếc Logrus không support cái này, tuy nhiên bạn có thể dùng một thằng khác như lumberjack mặc dù được khuyến khích là nên dùng logrotate chứ không nên xử lý ở tầng application, cơ mà mình thích thì mình dùng thôi, hơ hơ.\n Hook #  Có thể add hook tùy theo logging level, ví dụ gửi error đến một tracking service nào đó như BugSnag, ElasticSearch, Fluentd, Logstash,\u0026hellip; có rất nhiều library đi kèm, có thể xem thêm ở đây https://github.com/sirupsen/logrus#hooks\n Thread safe #   Logrus default sử dụng mutex để đảm bảo cho việc concurrent write (có thể tắt nếu cần). Logger out sử dụng 0_APPEND flag để write và mỗi lượt write nhỏ hởn 4K cho phép ghi multi-thread/multi-process (Refer to http://www.notthewizard.com/2014/06/17/are-files-appends-really-atomic/)  ","date":"12 December 2017","permalink":"/posts/log-trong-go-va-cac-van-de-ve-log/","section":"Posts","summary":"Vì sao cần phải log và cần phải log một cách chỉnh chu? #   Log là gì?","title":"Log trong Go và các vấn đề về log"},{"content":"","date":"12 December 2017","permalink":"/tags/logrus/","section":"Tags","summary":"","title":"logrus"},{"content":"","date":"12 December 2017","permalink":"/tags/lumberjack/","section":"Tags","summary":"","title":"lumberjack"},{"content":"","date":"12 December 2017","permalink":"/tags/tech/","section":"Tags","summary":"","title":"tech"},{"content":" Giao tiếp #   Lời nói không mất tiền mua, lựa lời mà nói cho vừa lòng nhau\n Giao tiếp là chuyện rất bình thường nhưng lại có thể vô tình trở thành ngọn nguồn của rất nhiều vấn đề. Trong khuôn khổ bài viết sẽ nói đến giao tiếp sẽ ảnh hưởng thế nào đến việc phát triển phần mềm, và có thể có ít nhiều liên quan đến các việc khác (hoặc không).\n    TL;DR Hãy giao tiếp như một team\n  Ngữ cảnh #  Để mô tả các vấn đề một cách dễ nhất cùng nhau đi qua câu chuyện như sau:\n Công ty X vừa nhận được một dự án xây dựng một mạng xã hội phú ông, hệ thống phần mềm cần làm là service API, app iOS và một cái web. App này mục đích chính là để các phú ông phú bà khoe của và một vài chức năng nho nhỏ khác\n  Ông Trum aka Boss (là người Việt họ Ông tên Trùm, tên nước ngoài không dấu là Trum): phú ông ở làng Phù Thủng người bỏ tiền ra cho dự án và kiêm luôn quyết định chức năng của App. Mr.Tony: là người quản lý mà phú ông thuê từ bên Mẽo về để hổ trợ quản lý dự án và Tony không biết nói tiếng Việt. Tí: Backend developer, chịu trách nhiệm làm API, sống ở làng Phù Đổng, tốt nghiệp cấp 3 trường làng biết code nhưng tiếng Anh lại bập bõm. Tèo: iOS developer, nhà giàu có điều kiện nên du học ở Ả Rập từ bé, nói tiếng Anh như gió. là iFan chân chính nên anh học code iOS cho đủ bài. Bạch Tuyết: Designer, sống trong rừng với 7 chú lùn, ban ngày rãnh rỗi nên Tuyết nhận thêm việc design freelance kiếm thêm chút tiền mua táo về pha detox uống giảm cân. Bờm: Bò mất giá nên anh không chăn bò nữa mà chuyển sang làm Quản lý ở công ty X aka project manager, anh là quản lý cho dự án này.   Quy trình hoạt động #  [Ông Trum] \u0026gt;\u0026mdash;\u0026ndash;\u0026gt; [Mr.Tony] \u0026gt;\u0026mdash;\u0026ndash;\u0026gt; [Bờm] + [Tuyết] \u0026gt;\u0026mdash;\u0026ndash;\u0026gt; [Tí] + [Tèo]\nCụ thể như sau:\n Ông Trum đưa ra yêu chung về ứng dụng, các chức năng mong muốn. Mr.Tony: phân tích yêu cầu chức năng và đưa ra các yêu cầu về kỹ thuật, tiến độ, thời gian, chất lượng. Bờm: nhận yêu cầu từ Tony, phân tích và lập kế hoạch phát triển. Rà soát và làm rõ các yêu cầu của ứng dụng, có thể coi như kiêm luôn Business Analyst Tuyết: xem xét yêu cầu và design. Tí: nhận design từ Bạch Tuyết và yêu cầu từ Bờm và code app, các yêu cầu nào cần đến API thì request Tèo cung cấp API. Tèo: nhận yêu cầu từ Bờm và bắt đầu làm API, viết documents cho API để Tí làm việc dễ dàng hơn. Tèo sẽ phải bắt đầu công việc trước để Tí có đủ API cần thiết để đảm bảo tiến độ.  Mọi người giao tiếp với nhau qua Skype\n Các vấn đề phát sinh #   1. My teammates are ninjas #   Vấn đề: #     Tèo có thắc mắc về design nên nhắn tin qua Skype cho Bạch Tuyết\n [09:00 AM] Tèo: Chị Tuyết ơi, cho em xin link file thiết kế màn hình Login \u0026lt;2h30 sau\u0026gt; [11:30 AM] Bạch Tuyết: Đây em https://tinyurl.com/DesignLogin [11:31 AM] Tèo: link bị 404 chị ơi :( \u0026lt;2h30 nữa\u0026gt; [02:00 PM] Bạch Tuyết: chị gửi lộn, link này nha https:/tinyurl.com/DesignLoginFinal [02:01 PM] Tèo: Cám ơn chị\n Và Tèo tốn 5h mòn mỏi đợi chờ. Đã có design, Tèo bắt tay vào làm, thử đăng nhập bằng API thì bị lỗi.\n [02:05 PM] Tèo: Tí ơi, API lỗi rồi, đăng nhập nó toàn báo status 500, Internal server error \u0026lt;1h sau\u0026gt; [03:05 PM] Tí: Phải gửi thêm mã OTP nữa. [03:06 PM] Tèo: Ờ, được rồi, sao không thấy ghi trong documents? [03:07 PM] Tèo: ơ, đăng nhập lần nữa thì nó báo status 403, Account is banned, sao kỳ vậy :( \u0026lt;2h sau\u0026gt; (Tí seen nhưng thấy báo bug nên không thèm trả lời) [05:00 PM] Tí: Gửi sai mã OTP, là bị khóa account nhé. [05:00 PM] Tèo: Sao không ghi trong documents?? [05:01 PM] Tí: Quên\n Và Tèo mất toi 8h lãng nhách chỉ vì ngồi đợi reply của team.\n Vấn đề: #   Teammates như ninja, thoắc ẩn thoắc hiện, không bao giờ thấy online, hỏi không trả lời,\u0026hellip; Lãng phí thời gian của team =\u0026gt; trễ tiến độ =\u0026gt; OT. Gây mất lòng tin lẫn nhau, quá mệt mỏi vì đợi chờ.   Giải pháp: #   (Bad) Chửi (lầm thầm hoặc thẳng mặt), lần sau nó hỏi thì cho nó đợi lại cho biết mặt, cho chừa tội làm trễ deadline của mình. Làm ngược lại là được. (Good) Góp ý nhẹ nhàng hoặc nên có các biện pháp ràng buộc để mọi người luôn luôn cố gắng trả lời tin nhắn sớm nhất có thể, tốt nhất là trong vòng 5', hạn chế làm trễ nãy công việc của nhau   2. Sử dụng kênh chat không hợp lý #   Vấn đề: #       Tèo cần thông tin về API tìm kiếm user (không có trong documents) và nhớ mang máng Tí đã gửi đâu đó trong đoạn chat group trên Skype, và bắt đầu scroll lên tìm kiếm đoạn chat đó, phải mất 30' Tèo mới tìm ra. Yêu cầu app có thay đổi và Bờm thông báo lên group chat, mọi người trao đổi một đoạn dài dài.  Tí đi chơi với bạn gái về thấy dài quá, lười đọc, bỏ luôn. Tèo vì thấy group chat phiền quá, mấy đoạn hội thoại không liên quan đến mình nên tắt notification luôn =\u0026gt; Vài hôm sau phát hiện ra code không đúng yêu cầu, OT ngồi sửa lại.   Bờm khiển trách và yêu cầu 2 người đọc lại chat log. Tí \u0026amp; Tèo bỏ 30' ngồi đọc đoạn chat, trao đổi phản biện và đã hiểu được yêu cầu, mặc dù mỗi người hiểu mỗi ý khác nhau?!       Giải pháp: #   Hạn chế document trên chat log, nếu điều kiện không cho phép thì nên note lại nhanh các thông tin kết luận Nên tổng hợp lại các ý đã thảo luận để tránh tốn thời gian xem lại chat log mà chưa chắc đã nhận được kết quả mong muốn (VD như trường hợp trên nếu Bờm chủ động tổng hợp lại sẽ đỡ tốn thời gian của cả Tí và Tèo - 1h ngồi xem) Sử dụng các kênh chat nào có notification hợp lý, vừa đảm bảo team nắm được thông tin, vừa đảm bảo không bị phân tâm vì quá nhiều notification. Slack khá tốt trong trường hợp này với các tính năng như notification theo cá nhân, pin post, link documents, snippet,\u0026hellip; Skype có nhiều cải thiện nhưng vẫn khá tệ (vd không thể phân biệt khi nào notification do người khác tag mình hay notification từ message hay các loại notification khác)   3. Luôn luôn lịch sử và hòa nhã #   Vấn đề: #   Bờm vốn là dân chăn bò nên hơi thẳng tính, mỗi khi có gì không vừa lòng Bờm chửi ngay. \u0026ldquo;Không hiểu à? Gì ngu như con bò vậy, à không, mấy con bò anh nói một tiếng là tụi nó đi theo liền nhé.\u0026rdquo; Mọi người trong team biết tính Bờm nhưng làm gì có ai bị chửi mà vui, lại còn chửi nặng.   Giải pháp: #   We are a team, chửi nhau làm chi? Hãy hòa nhã và lịch sự, thẳng thắng là tốt nhưng đừng thẳng quá, hãy luôn kiên nhẫn và mềm dẻo. Sử dụng từ ngữ khôn khéo, nhẹ nhàng và tình cảm, thay vì luôn đẩy trách nhiệm về đối phương (vd \u0026ldquo;Chổ đó dễ ợt mà em không hiểu à?\u0026rdquo;, \u0026ldquo;phần đó em làm có bug kìa, sửa lại đi, ẩu quá\u0026rdquo;,\u0026hellip;) thì nên giảm nhẹ lại (\u0026ldquo;Có phần nào anh nói chưa rõ không?\u0026rdquo;, \u0026ldquo;Phần đó hình như có bug, em kiểm tra giúp anh nhé, nó bị abc\u0026hellip; lẽ ra phải là xyz\u0026hellip;, cám ơn em nhé\u0026rdquo;)   4. I\u0026rsquo;m not mind reader! #   Vấn đề: #      Bờm: @Tí ơi, bug \u0026lt;ném cho cái screen shoot\u0026gt; Tí: Đâu anh, em có thấy gì đâu Bờm: Đó, anh click vào cái button đó nó không ra gì hết. Tí: button nào anh, có 5 cái button trên đó lận. Bờm: Button màu đỏ đó Tí: Button màu đó nào anh, 3 cái cancel/stop/burn anh nói cái nút nào Bờm: Trời ơi, cái nút burn đó, sao chậm tiêu quá vậy, hỏi tới hỏi lui nữa, anh nói ngắn gọn em phải hiểu chứ Tí: Dạ\u0026hellip; (ai biết ông nghĩ gì mà hiểu)\n  Giải pháp: #   Luôn nói ngắn gọn mà rõ ràng, không ai biết được bạn đang nghĩ gì đâu   5. We are a team not nemesis #   Vấn đề: #      Tí phàn nàn Tuyết làm UI/UX tệ quá, Tuyết ôm hận trong lòng và thỉnh thoảng đổi design trước ngày deadline của Tí với lý do \u0026ldquo;đổi UI/UX cho vừa lòng Tí\u0026rdquo; Tí trễ deadline nên bị stress, giận cá chém thớt, Tí quay qua hằn hộc với Tèo, đòi phải thay đổi API cho đúng với design. Tèo lọ mọ sửa và lâu lâu chơi lại Tí bằng việc lâu lâu update API mà không báo trước cho crash App chơi. Cả team xỉa xói lẫn nhau, soi mói và đâm chọt nhau ngay khi có thể cho bỏ ghét\n  Giải pháp: #   Luôn nhớ rằng chúng ta là một team, không phải kẻ thù. Thái độ thù địch không giúp ích được gì cả, nếu muốn đi nhanh hãy đi một mình, nếu muốn đi xa hãy đi cùng nhau, đừng níu kéo, dìm dập lẫn nhau.   6. Tam sao thất bản #   Vấn đề: #      Giải pháp: #   Làm cho mọi thứ thật rõ ràng, document cụ thể và chi tiết. Nếu phát sinh vấn đề cần làm rõ, không tạo ra điểm mù và chắn chắc mọi người có liên quan đều nắm được   7. I\u0026rsquo;m superman, everybody follow me! #   Tình huống: #  App có chức năng cơ bản là đăng nhập với username và password, Tuyết nghĩ nó quá đơn giản và không đủ bảo mật với một app cho nhà giàu, Tuyết quyết định thêm vào một nút Đăng nhập bằng võng mạc\n Vấn đề: #   API được thiết kế không phù hợp với design, chức năng mới không có yêu cầu rõ ràng, Tí bắt đầu gào thét. Chức năng quá dị, chưa từng làm bao giờ, tốn thời gian để research, prototype làm ban đầu không đúng với yêu cầu, Tèo bắt đầu gào thét. Design làm cho estimation sai bét nhè, break plan, team hỏi flow hoạt động nhưng Bờm không biết, Bờm bắt đầu gào thét.\n  Giải pháp 1 (bad): OT thôi!! Cả team cắm mặt ngồi code chức năng mới, vừa code vừa chửi. Giải pháp 2 (good): Hãy giao tiếp như một team. Trao đổi với các thành viên trong team để tìm ra giải pháp thuận lợi nhất cho tất cả các bên (design, API, mobile app thay đổi ít nhất có thể). Cả team quyết định thay đổi thành xác nhận bằng OTP.   8. \u0026hellip; #  Có cả tỉ vấn đề khác mà giờ lười quá không viết nữa (￣▽￣)\n Kết #   Không có cái kết nào cả vì chuyện giao tiếp là chuyện không bao giờ dứt, các vấn đề ở trên cũng chưa hẳn là vấn đề, các giải pháp cũng chưa hẳn là giải pháp, mọi thứ còn tùy thuộc vào thời điểm, vào team, vào công việc, vân vân và mây mây\u0026hellip; Mục đích cuối cùng của việc thành lập một team là để hoàn thành công việc một cách tốt nhất (thời gian, chất lượng, số lượng,\u0026hellip;) Mọi thứ thật sự tốt nếu nó hợp lý và giải quyết được vấn đề và mục tiêu chung của cả team.  ","date":"27 August 2017","permalink":"/posts/chuyen-giao-tiep/","section":"Posts","summary":"Giao tiếp #   Lời nói không mất tiền mua, lựa lời mà nói cho vừa lòng nhau","title":"Chuyện giao tiếp"},{"content":"","date":"27 August 2017","permalink":"/tags/talk/","section":"Tags","summary":"","title":"talk"},{"content":"    Slow query là gì? #  Khi các câu query chậm hơn một thời gian nhất định tùy theo bạn định nghĩa, ví dụ chậm hơn 50ms, thì các câu query đó được xem là slow query. Và tùy theo ứng dụng mà sẽ có định nghĩa khác nhau, một vài ví dụ:\n Bạn viết một API authentication cho cái app nho nhỏ và bạn hy vọng nó chạy càng nhanh càng tốt, tối đa là 30ms/request =\u0026gt; Query phải \u0026lt; 30ms. Bạn viết một ứng dụng liên quan đến tiền bạc, thanh toán online. Đòi hỏi bắt buộc là phải chính xác và an toàn, chậm một chút cũng không sao =\u0026gt; Query có thể nới ra thành \u0026lt; 100 ms.  Tùy theo mục đích mà có tiêu chuẩn thời gian khác nhau\n Slow query xảy ra khi nào? #  Có rất nhiều trường hợp sẽ xảy ra slow query như:\n Query condition trên column thiếu index Query bị lock bởi các câu query, transaction,\u0026hellip; Câu query không được optimize nên dẫn đến query thừa hoặc không tối ưu, sequence scan thay vì index scan,\u0026hellip; Cấu hình máy không đáp ứng được nhu cầu query hiện tại. \u0026hellip;  Có khá nhiều nguyên nhân có thể xảy ra và để có thể giải quyết thì việc đầu tiên là phải biết nó có xảy ra 😄\n Log slow query #  Postgresql cho phép bạn log các câu query, statement,\u0026hellip; và nhiều thứ khác ra. Để log ra thì bạn có thể edit file postgresql.config và thay đổi theo nhu cầu, mình liệt kê một vài thông số cơ bản phục vụ cho bài viết, bạn có thể xem thêm ở đây https://www.postgresql.org/docs/current/static/runtime-config-logging.html\n log_directory: Nơi lưu log, mặc định thường là pg_log log_filename: format name của file log log_min_duration_statement : Nếu lớn hơn thời gian này query sẽ được cho là slow query (đơn vị milisecond)  Save lại và reload (hoặc restart) PostgreSQL. Khi có slow query PostgreSQL sẽ giúp bạn ném vào log.\nNote nhỏ: Khi bạn restart PostgreSQL, các connection của client đều sẽ bị disconnect\n (╯°□°）╯︵ ┻━┻  nhưng nếu bạn reload thì không sao cả, mọi thứ vẫn bình thường\n (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧  sudo service postgresql reload\nKhi log ra bạn sẽ thấy nhiều thông tin dạng thế này và fix dễ dàng hơn\n593821c2.21a2 2017-06-08 00:00:41 ICT LOG: duration: 439.218 ms execute \u0026lt;unnamed\u0026gt;: SELECT * FROM \u0026quot;users\u0026quot; WHERE (username = $1) LIMIT 1 593821c2.21a2 2017-06-08 00:00:41 ICT DETAIL: parameters: $1 = 'trietphm'  pgBadger #   Vì sao lại cần log analyzer? #  Sau một ngày đẹp trời bạn mở file log lên và chợt nhận ra nó nặng cả GB với hằng hà sa số log query slow, với cơ man nào là các câu query dài loằng ngoằng hay những câu query ngắn ngủn như SELECT * FROM users WHERE id = $1 mà bạn chắc chắn không thể nào chậm mà vẫn xuất hiện trong đây? Rồi có những câu query bạn cũng không biết nó đến từ server nào hay hành tinh nào? Không biết câu query nào chậm nhất để mà optimize? Không biết và không biết.\nMột đống hỗn độn và gần như vô dụng!\n pgBadger là gì? #  pgBadger là một PostgreSQL log analyzer nhỏ gọn được viết bằng Perl script giúp bạn phân tích và report từ PostgreSQL log file. Sẽ giúp bạn khai thác được file hỗn độn kia, đập đá ra vàng. Sau khi xử lý pgBadge sẽ xuất ra cho bạn một file HTML (hoặc JSON) report về file log đó.\n Cài đặt #   Tải pgBadger Và make  tar xzf pgbadger-9.x.tar.gz cd pgbadger-9.x/ perl Makefile.PL make \u0026amp;\u0026amp; sudo make install  Trong quá trình cài đặt có thể bị lỗi và bạn cần cài thêm perl-devel. Cài đặt trong Centos qua rpm sudo yum install perl-devel   Update format log file #  Để pgBadger có thể đọc được tốt file log, bạn cần update lại một chút trong config:\n log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h ' log ra các thông tin user, database name, application và client ip address Enable các option log khác để lấy được nhiều thông tin hơn:   log_checkpoints = on log_connections = on log_disconnections = on log_lock_waits = on log_temp_files = 0 log_autovacuum_min_duration = 0 log_error_verbosity = default  Bạn có thể xem thêm trong Document    Parse log \u0026amp; export report #  Cách đơn giản nhất:\npgbadger \u0026lt;file_log\u0026gt; \u0026lt;output.html\u0026gt; Mặc định pgBadger sẽ để output là out.html nếu không được định nghĩa\n Report #  Khi mở file output html lên sẽ có rất nhiều thông tin phân tích từ log file đó, một số hình ảnh:         ","date":"10 June 2017","permalink":"/posts/phan-tich-slow-query-postgresql-voi-pgbadger/","section":"Posts","summary":"Slow query là gì? #  Khi các câu query chậm hơn một thời gian nhất định tùy theo bạn định nghĩa, ví dụ chậm hơn 50ms, thì các câu query đó được xem là slow query.","title":"Phân tích slow query PostgreSQL với pgBadger"},{"content":"Bắt đầu chuyển sang dùng Vim làm editor chính một cách nghiêm túc sau nhiều lần thử, bỏ cuộc và quay trở về Sublime Text. Còn về nguyên nhân bỏ cuộc là vì không quen với VIM được, do có nhiều thứ quá khác với Sublime Text, chính xác là trên Sublime Text có mà VIM lại không có, nên lần này mình sẽ setup toàn bộ những thứ bên Sublime Text qua VIM hết.\n Vì sao phải dùng VIM? #   Hầu hết thời gian mình đều làm việc trong terminal nên chuyển editor sang VIM luôn cho tiện. Việc di chuyển trong VIM nhanh và thuận tiện hơn so với các editor/IDE khác (dĩ nhiên nếu không dùng VIM mode). Hạn chế sử dụng chuột để tăng tốc độ thao tác. Nhiều thứ để custom phù hợp với nhu cầu, khả năng tùy biến cao. Làm màu, trông có vẻ giống hắc cơ. Động lực để chuyển sang bàn phím 60% để mang đi mang về cho tiện ._.   Cài đặt #  Tuỳ theo nhu cầu bạn có thể chọn Vim, NeoVim, hoặc MacVim tuỳ thích. Thế mình chọn cái nào à? Mình chọn NeoVim nhé, vì một tính năng rất mạnh mà NeoVim đã support sẳn TrueColour, à ờ, tóm lại cũng là màu mè thôi, cho nó đẹp. Nếu bạn là newbie thì mình khuyến khích dùng Vim nhé.\nLink download \u0026amp; hướng dẫn cài đặt bên dưới nhé:\n Vim NeoVim MacVim   Sử dụng Vim #  Mở terminal lên và gõ vim để bắt đầu nào (Windows thì bạn click vào cái icon sau khi cài đặt của nó nhé).\n Các vấn đề cơ bản #   Mode #  Vim có tổng cộng 6 modes hoạt động normal, insert, visual, select, command-line, Ex-mode. Mặc định khi mở Vim lên sẽ là mode normal. Trong đó 3 modes mình thường được sử dụng nhất là:\n normal: Dùng để di chuyển và thao tác trong đoạn text, và sẽ là mode được back lại khi ấn ESC ở mode khác. insert: Như tên gọi, để thêm text mới vào. visual: tương tự như normal nhưng cho phép bôi đen (select) text để thực hiện các thao tác với đoạn bôi đen đó.   Một vài phím và lệnh cơ bản #   [\u0026hellip;] Sau khi viết một đoạn và thấy quá lười nên thôi mấy bạn xem bài của @huytd ở đây nha, hình ảnh đẹp và rõ ràng dễ hiểu Làm quen VIM trong 5 phút   Học VIM nhanh hơn, vui hơn, thông minh hơn #   Đầu tiên phải kể đến của nhà trồng được: Tutor. Mặc định trong Vim có một hệ thống Tutorial khá xịn, tại mode normal bạn gõ :Tutor và làm theo Tutorial nhé, sau khoảng 30' bạn có thể thoải mái thao tác trong Vim. Vừa học vừa chơi: VIM Advantures Một game trên nền web giúp bạn vừa học vừa chơi, di chuyển thao tác bằng các phím trong VIM. Bạn có thể chơi thử Level 1 rồi quyết định có mua license hay không (không free đâu nhé T_T) OpenVim một website giúp bạn tập thao tác VIM online qua từng bài học, thực hành thẳng trên website. Learn Vimscripts the Hard Way một ebook hướng dẫn các bạn nâng trình độ dùng VIM lên một tầm cao mới   Di cư từ Sublime Text sang VIM #  Vấn đề đầu tiên khi chuyển sang VIM là cảm thấy quá nhiều thứ khác lạ và thiếu thốn, có mỗi cái màn hình đen chán phèo. Bình tĩnh nhé, hầu hết các tính năng ở Sublime Text đều có thực hiện giống hoặc tốt hơn trong VIM nhờ vào hệ thống plugin đồ sộ cùng hệ thống có sẳn cho phép bạn tinh chỉnh nhiều thứ theo ý mình. Và đều được định nghĩa trong file .vimrc (thường nằm ở ~/.vimrc)\n Plugin management #  Có thể cài đặt Plugin trong VIM trực tiếp bằng cách pull code từ github về và chép vào thư mục ~/.vim/bundle. Tuy nhiên, cách tốt nhất vẫn là dùng hệ thống quản lý Plugin như Vundle, Pathegon, Vim-Plug, Neo-Bundle Cá nhân mình dùng Vim-Plug (trước đó dùng Vundle) vì Vundle hiện tại đã không còn maintain, bên cạnh đó Vim-Plug cũng đơn giản, dễ dùng, load, update plugins cũng nhanh hơn hẳn.\n Cài đặt: https://github.com/junegunn/vim-plug#installation Cách dùng: https://github.com/junegunn/vim-plug#usage Thêm các plugins cần dùng trong file .vimrc Lưu lại và reload file .vimrc (có thể reload nhanh bằng command :source % mà không cần khởi động lại VIM) :PlugInstall để cài đặt plugins Ngoài ra :PlugUpdate để update toàn bộ plugins, hoặc :PlugClean để clean các plugins nào không còn nằm trong .vimrc, có thể xem thêm ở đây      Dot file, .vimrc, config cho vim #  Có rất nhiều người share config trong VIM trên github (và các dotfiles khác như tmux, zsh) mà các bạn có thể tham khảo để dùng cho bản thân, VD như vimrc, ThoughtBot, dotfiles Bạn có thể lên đây cóp nhặt các thứ cần thiết cho mình và ném nó vào file .vimrc, phần sau mình sẽ giới thiệu một số thứ thông dụng.\nTuy nhiên:\n Don\u0026rsquo;t put any lines in your vimrc that you don\u0026rsquo;t understand.\n  Các vấn đề thường gặp khi bắt đầu dùng VIM #  Các phần sau bạn có thể thử nhanh qua command : hoặc sửa trong .vimrc rồi reload lại VIM. Có thể check nhanh giá trị của biến bằng command :set \u0026lt;variable\u0026gt;?, vd :set nu?\n Dùng chuột, hoàn toàn có thể:  if has('mouse') set mouse=a endif  Copy từ VIM ra ngoài Clipboard, mặc định VIM chỉ lưu trong Register (xem thêm) lúc bạn yank:  set clipboard=unnamedplus  Hiện line number  set nu  Tự động cập nhật khi file thay đổi (bởi chương trình khác)  set autoread set autowrite  Tự động indent  set autoindent set si \u0026quot;smart indent  Bật syntax  syntax on  Tắt các thể loại files backup, swap, khá là annoy và không cần thiết vì mình đã dùng git rồi  set nobackup set nowb set noswapfile set backupdir=~/tmp,/tmp set backupcopy=yes set backupskip=/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/* set directory=/tmp  Map key #  Để có thể tận dụng hết tất cả sức mạnh của VIM cũng như thao tác một cách nhanh nhất thì không thể nào bỏ qua tính năng map - cho phép bạn sử dụng tổ hợp phím nhanh nhất, bạn có thể xem thêm ở đây Ví dụ mình thường map một số phím như\n\u0026quot; Map leader key let mapleader = \u0026quot;,\u0026quot;\t\u0026quot; map leader key to , let g:mapleader = \u0026quot;,\u0026quot; \u0026quot; Fast saving nmap \u0026lt;leader\u0026gt;w :w!\u0026lt;cr\u0026gt; \u0026quot; Map Esc to jj :imap jj \u0026lt;Esc\u0026gt; \u0026quot; Hide highlight map \u0026lt;silent\u0026gt; \u0026lt;leader\u0026gt;\u0026lt;cr\u0026gt; :noh\u0026lt;cr\u0026gt; \u0026quot; Move between windows map \u0026lt;C-j\u0026gt; \u0026lt;C-W\u0026gt;j map \u0026lt;C-k\u0026gt; \u0026lt;C-W\u0026gt;k map \u0026lt;C-l\u0026gt; \u0026lt;C-W\u0026gt;l map \u0026lt;C-h\u0026gt; \u0026lt;C-W\u0026gt;h Nói chung nếu những phím/tổ hợp phím/command nào thường xuyên sử dụng, bạn hoàn toàn có thể map lại thành phím khác để rút ngắn thời gian thao tác của mình.\n Nhưng vẫn chưa giống SublimeText? #  Q: VIM cùi bắp, không có auto complete này. A: Vim có nhiều Plugin support auto-complete như YouCompleteMe, neocomplete   Q: Làm thế nào để Split Screen đây? A: Dùng command :split \u0026amp; vsplit để chia màn hình ngang và dọc. Xem thêm để làm việc nuột hơn nà.\nQ: Làm sao để di chuyển giữa các panes (màn hình)? A: Dùng chuột click cũng được, hoặc tốt nhất dùng tổ hợp phím \u0026lt;C-W\u0026gt;j, \u0026lt;C-W\u0026gt;k, \u0026lt;C-W\u0026gt;l, \u0026lt;C-W\u0026gt;h. \u0026lt;C\u0026gt; ở đây là phím Ctrl.\nQ: VIM có SideBar folders không? A: Có plugin support nhé NERDTree   Q: Thêm/xóa file/thư mực như thế nào nhỉ, phải switch ra Terminal à? A: Không cần phải ra terminal đâu, ở NERDTree bạn chỉ việc ấn phím m tại node cần thao tác, một menu sẽ hiện ra cho bạn chọn lựa   Q: Vậy còn Mini map? A: Yup, Minimap, nhưng cá nhân mình nghĩ dùng Tagbar sẽ tiện dụng hơn. Minimap:   Tagbar:   Q: Mình hay dùng Mutitple Selection. A: Xem nào, Multiple Selection có nhiều thứ, ta đi qua từng cái nhé:\n  Thêm một hàng: Mặc định ở Windows là Ctrl+Alt+Up \u0026amp; Ctrl+Alt+Down (OS X: Ctrl+Shift+Up \u0026amp; Ctrl+Shift+Down). A: Đối với VIM, khi ở mode Normal có thể ấn o để thêm một hàng phía dưới và O để thêm phía trên và sau đó sẽ switch sang mode Insert luôn để bạn có thể bắt đầu gõ. Ngoài ra bạn có thể gõ 5o\u0026lt;Esc\u0026gt; để thêm nhanh 5 hàng, tính năng repeat tiện lợi của VIM.\n  Chọn, sửa nhanh nhiều vị trí: Ctrl+d hoặc Command+d A: VIM thì mình dùng Plugin vim-multiple-cursors nhé, ngoài chức năng như Sublime Text bạn còn có thể search được bằng cả Regex     Select all bằng Alt+F3 (Windows+Linux) hoặc Ctrl+Command+g trên OS X? A: Vẫn dùng Plugin bên trên nha, bạn xem trong wiki để tìm hiểu thêm.\n  Q: Còn tab thì sao? A: Hiển nhiên rồi, ngoài ra VIM còn có thể một khái niệm nữa là Buffer, xem thêm tab ở đây và buffer ở đây   Q: Navigation bằng Ctrl + P thì sao, siêu tiện luôn A: VIM có nhiều Plugin phục vụ cho việc này, bạn có thể dùng hàng Việt Nam chất lượng cao CtrlP hoặc dùng Fzf   Q: Search một từ trong nhiều file? Ví dụ seach chữ function trong một project có nhiều thư mục, Sublime Text thì click phải vào Folder rồi search, còn VIM thì sao, đâu có click phải vào NERDTree được? A: VIM bạn có thể search bằng built-in của VIM là :grep, :lgrep, :vimgrep, :lvimgrep http://vim.wikia.com/wiki/Find_in_files_within_Vim, cá nhân mình dùng ack.vim kết hợp cùng the_silver_searcher   Q: Ops, không ấn Ctrl + / để comment code như các IDE khác à? A: Để comment code bạn cần dùng Plugin NERD Commenter và sau đó có thể map phím Ctrl + / để execute lệnh comment\nQ: Các tổ hợp phím tắt thì sao nhỉ? Ví dụ như mình muốn copy nhanh toàn bộ code trong một tag hoặc function? A: Ở mode Normal gõ yip - copy bên trong tag hoặc yap copy cả tag, ngooài ra có rất nhiều phím tắt khác, để thao tác nhanh nhất bận nên tham khảo vim cheatsheet.\nNhững phần bên trên chỉ là phần nhỏ thôi, bạn có thể xem thêm trong :help hoặc tự map các tổ hợp phím tắt riêng cho mình giúp tăng tốc độ làm việc.\n Shock văn hóa, quá nhiều thứ để nhớ, thôi nghỉ, không VIM nữa #  Ban đầu mình cũng không thể chuyển sang VIM ngay được, không thể nào thao tác quen được. Nếu quyết định chuyển từ từ sang, vẫn dùng Sublime Text nhưng hạn chế không dùng đến các phím arrow và pageUp/pageDown thay vào đó là dùng các phím tắt trong VIM\n  Đầu tiên mình cài thêm Plugin vào trong Sublime Text để làm quen dần thao tác di chuyển Vintage(ST2) hoặc Vintagous(ST3)\n  Cài thêm Vimium vào Chrome luôn cho ngầu. Install xong thì ấn ? để xem danh sách phím tắt nhé.\n     Rất nhanh và tiện, hoàn toàn thao tác bằng phím, không rờ tới chuột.\n Tiếp theo thì làm gì? #   Tùy theo ngôn ngữ mà bạn đang dùng mà bạn có thể cài thêm cái plugin hổ trợ để viết code nhanh hơn, tốt hơn, ít bug hơn. Nếu chức năng nào đó mà bạn quen dùng nhưng không có hãy mạnh dạn tùy biến vimrc hoặc Google thử, hầu hết sẽ có thứ bạn cần. Sao khi đã thao tác nhanh rồi thì việc tiếp theo là\u0026hellip; đi lòe mấy đứa khác thôi :troll:.  Chúc các bạn may mắn\nTriet 18-02-2017\n","date":"19 February 2017","permalink":"/posts/sublime-text-to-vim/","section":"Posts","summary":"Bắt đầu chuyển sang dùng Vim làm editor chính một cách nghiêm túc sau nhiều lần thử, bỏ cuộc và quay trở về Sublime Text.","title":"Sublime Text to VIM"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]